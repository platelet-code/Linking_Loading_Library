1. 导致C语言的共享库ABI改变的行为主要有如下4个:
    - 导出函数的行为发生改变, 也就是说调用这个函数以后产生的结果与以前不一样, 不再满足旧版本规定的函数行为准则.
    - 导出函数被删除.
    - 导出数据的结构发生变化, 比如共享库定义的结构体变量的结构发生改变.
    - 导出函数的接口发生变化, 如函数返回值, 参数被更改.


2. 开发一个导出接口为C++的共享库, 要注意以下事项:
    - 不要在接口类中使用虚函数, 万不得已要使用虚函数时, 不要随意删除, 添加或在子类中添加新的实现函数, 这样会导致类的虚函数表结构发生变化.
    - 不要改变类中任何成员变量的位置和类型.
    - 不要删除非内嵌的public或protected成员函数.
    - 不要将非内嵌的成员函数改变成内嵌成员函数.
    - 不要改变成员函数的访问权限.
    - 不要在接口中使用模板.
    - 不要改变接口的任何部分或不要使用C++作为共享库接口.


3. 共享库版本命名
    - Linux有一套规则来命名系统中的每一个共享库, 它规定共享库的文件命名规则必须如下:
          libname.so.x.y.z
    - 最前面使用前缀 lib, 中间是库的名字和后缀 .so, 最后面跟着的是三个数字组成的版本号, 'x'表示主版本号, 'y'表示次版本号, 'z'表示发布版本号.
    - 主版本号表示库的重大升级, 不同主版本号的库之间是不兼容的, 依赖于旧的主版本号的程序要改动相应的部分, 并且重新编译, 才可以在新版的共享库
      中运行; 或者, 系统必须保留旧版的共享库, 使得那些依赖于旧版共享库的程序能够正常运行.
    - 次版本号表示库的增量升级, 即增加一些新的接口符号, 且保持原来的符号不变. 在主版本号相同的情况下, 高的次版本号的库向后兼容低的次版本号的库.
      一个依赖于旧的次版本号共享库, 可以在新的次版本号共享库中运行, 因为新版中保留了原来所有的接口, 并且不改变它们的定义和含义.
    - 发布版本号表示库的一些错误的修正, 性能的改进等. 并不添加任何新的接口, 也不对接口进行更改. 相同主版本号, 次版本号的共享库, 不同的发布
      版本号之间完全兼容, 依赖于某个发布版本号的程序可以在任何一个其他发布版本号中正常运行, 而无须做任何修改.


4. SO-NAME
    - 共享库的主版本号和次版本号决定了一个共享库的接口, 
    - 对于新的系统来说, 包括Solaris和Linux, 普遍采用一种叫做SO-NAME的命名机制来记录共享库的依赖关系. 每个共享库都有一个对应的SO-NAME, 这个
      SO-NAME即共享库的文件名去掉次版本号和发布版本号, 保留主版本号.  libfoo.so.2.6.1  SO-NAME -> libfoo.so.2
    - 在Linux系统中, 系统会为每个共享库在它所在的目录创建一个跟 SO-NAME 相同的并且指向它的软链接. 实际上这个软链接会指向目录中主版本号相同,
      次版本号和发布版本号最新的共享库.
    - 建立以SO-NAME为名字的软链接的目的是, 使得所有依赖某个共享库的模块, 在编译, 链接和运行时, 都使用共享库的SO-NAME, 而不使用详细的版本号.
    - 一个可行的方法就是编译输出ELF文件时, 将被依赖的共享库的SO-NAME保存到 .dynamic 中, 这样当动态链接器进行共享库依赖文件查找时, 就会根据
      系统中各种共享库目录中的SO-NAME软链接自动定向到最新版本的共享库.
    - 当共享库进行升级的时候, 如果只是进行增量升级, 即保持主版本号不变, 只改变次版本号或发布版本号, 那么我们可以直接将新版的共享库替换掉旧版,
      并且修改SO-NAME的软链接指向新版本共享库, 即可实现升级; 当共享库的主版本号升级时, 系统中就会存在多个SO-NAME, 由于这些SO-NAME并不相同,
      所以已有的程序并不会受影响.
    - Linux中提供一个工具叫做 ldconfig, 当系统中安装或更新一个共享库时, 就需要运行这个工具, 它会遍历所有的默认共享目录, 比如/lib, /usr/lib,
      然后更新所有的软链接, 使它们指向最新版本的共享库; 如果安装了新的共享库, 那么 ldconfig 会为其创建相应的软链接.


5. 次版本号交会问题
    - 动态链接器进行动态链接时, 只进行主版本号的判断, 即只判断SO-NAME, 如果某个被依赖的共享库SO-NAME与系统中存在的实际共享库SO-NAME一致,
      那么系统就认为接口兼容, 而不再进行兼容性检查. 当某个程序依赖于较高的次版本号的共享库, 而运行于较低次版本号的共享库系统时, 就可能产生
      缺少某些符号的错误. 因为次版本号只保证向后兼容, 并不保证向前兼容, 新版的次版本号的共享库可能添加了一些旧版本没有的符号. 这种次版本号
      交会问题并没有因为SO-NAME的存在而得到任何改善, 对于这个问题, 现代的系统通过一种更加精巧的方式来解决, 那就是符号版本机制.


6. 基于符号的版本机制
    - 在程序运行时, 动态链接器会通过程序内记录的它所依赖的所有共享库的符号集合版本信息, 然后判定当前系统共享库中的符号集合版本是否满足这些依赖
      的版本集合. 通过这样的机制, 就可以保证那些在高次版本共享库的系统中编译的程序在低次版本共享库中运行.
    - 如果编译源代码为 lib.c, 符号版本脚本文件为 lib.ver
          gcc -shared -fPIC lib.c -Xlinker --version-script lib.ver -o lib.so


7. 共享库系统路径
    - FHS(File Hierarchy Standard)规定, 一个系统中主要有3个存放共享库的位置, 它们分别如下:
    - /lib: 这个位置主要存放系统最关键和基础的共享库, 比如动态链接器, C语言运行库, 数学库等. 这些库主要是那些/bin和/sbin下的程序所要用到的库,
      还有系统启动时需要的库.
    - /usr/lib: 这个目录下主要保存的是一些非系统运行时所需要的关键性的共享库, 主要是一些开发时用到的共享库, 这些共享库一般不会被用户的程序或
      shell 脚本直接用到. 这个目录下面还包含了开发时可能会用到的静态库, 目标文件等.
    - /usr/local/lib: 这个目录用来放置一些跟操作系统本身并不十分相关的库, 主要是一些第三方的应用程序的库. 比如我们我们在系统中安装了python语言
      的解释器, 那么与它相关的共享库可能会被放到 /usr/local/bin 下, GNU的标准库推荐第三方的程序应该默认将库安装到/usr/local/lib下.
    - 所以总体来看, /lib和/usr/lib是一些很常用的, 成熟的, 一般是系统本身所需要的库; 而/usr/local/lib是非系统所需的第三方程序的共享库.


8. 共享库查找过程
    - 在Linux系统中, 动态链接器是/lib/ld-linux.so.X, 程序所依赖的共享对象全部由动态链接器负责装载和初始化. 我们知道任何一个动态链接的模块所
      依赖的模块路径保存在 .dynamic 段里面, 由DT_NEED类型的项表示. 动态链接器对于模块的查找有一定的规则:
         (1)如果DT_NEED里面保存的是绝对路径, 那么动态链接器就按照这个路径去查找;
         (2)如果DT_NEED里面保存的是相对路径, 那么动态链接器会在 /lib, /usr/lib, /etc/ld.so.conf 配置文件指定的目录中查找共享库. 为了程序的
            可移植性和兼容性, 共享库的路径往往是相对的.

    - 如果动态链接器在每次查找共享库时都去遍历这些目录, 那将会非常耗费时间. 所以Linux系统中都有一个叫做ldconfig的程序, 这个程序的作用是为共享
      库目录下的各个共享库创建, 删除或更新相应的SO-NAME, 这样每个共享库的SO-NAME就能够指向正确的共享库文件; 并且这个程序还会将这些SO-NAME收集
      起来, 集中存放到/etc/ld.so.cache文件里面, 并建立一个SO-NAME的缓存. 当动态链接器要查找共享库时, 它可以直接从/etc/ld.so.cache里面查找.

    - 如果动态链接器在/etc/ld.so.cache里面没有找到所需要的共享库, 那么它还会遍历/lib和/usr/lib这个目录, 如果还是没找到, 就宣告失败.

    - 如果我们在系统指定的共享库目录下添加, 删除或更新任何一个共享库, 或者我们更改了 /etc/ld.so.conf 的配置, 都应该运行ldconfig这个程序, 以便
      调整SO-NAME和/etc/ld.so.cache. 很多软件包的安装程序在往系统里面安装共享库以后都会调用ldconfig.


9. 环境变量
    - LD_LIBRARY_PATH: 在Linux系统中, LD_LIBRARY_PATH是一个由若干个路径组成的环境变量, 每个路径之间用冒号隔开. 如果我们为某个进程设置了
            LD_LIBRARY_PATH, 那么进程在启动时, 动态链接器在查找共享库时, 会首先查找由LD_LIBRARY_PATH指定的目录.
    - LD_PRELOAD: 我们可以指定预先装载的一些共享库甚至是目标文件. 在LD_PRELOAD里面指定的文件会在动态链接器按照固定规则搜索共享库之前装载,
            它比LD_LIBRARY_PATH里面所指定的目录中的共享库还要优先. 无论程序是否依赖于它们, LD_PRELOAD里面指定的共享库或目标文件都会被装载.
    - LD_DEBUG: 这个变量可以打开动态链接器的调试功能, 当我们设置这个变量时, 动态链接器会在运行时打印出各种有用的信息.


10. 共享库的创建和安装
    - 共享库的创建: 比如我们有 libfoo1.c 和 libfoo2.c 两个源代码文件, 希望产生一个 libfoo.so.1.0.0 的共享库, 这个共享库依赖于 libbar1.so
      和 libbar2.so 这两个共享库, 使用如下命令行:
        -> gcc -shared -fPIC -wl,-soname,libfoo.so.1 -o libfoo.so.1.1.0 libfoo1.c libfoo2.c -lbar1 -lbar2

    - 清除符号信息: 使用一个叫 strip 的工具清除掉共享库或可执行文件的所有符号和调试信息
        -> strip libfoo.so

    - 共享库的安装: 建立 SO-NAME 的办法也是使用ldconfig, 只不过需要指定共享库所在的目录
        -> ldconfig -n shared_library_directory

    - 共享库构造和析构函数
         (1) GCC提供了一种共享库的构造函数, 只要在函数声明时加上 __attribute__((constructor)) 的属性, 即指定该函数为共享库构造函数, 拥有
             这种属性的函数会在共享库加载时被执行, 即在程序的main函数之前执行. 如果我们使用 dlopen()打开共享库, 共享库构造函数会在 dlopen() 
             返回之前执行.
         (2) 与共享库构造函数相对应的是析构函数, 我们可以使用在函数声明时加上 __attribute__((destructor)) 的属性, 这种函数会在 main() 
             函数执行完毕之后执行(或者是程序调用exit()时执行). 如果共享库是运行库时加载的, 那么我们使用 dlclose() 来卸载共享库时, 析构函数
             将会在 dlclose() 返回之前执行. 声明构造和析构函数的格式如下:
                void __attribute__((constructor)) init_function(void);
                void __attribute__((destructor)) fini_function(void);
         (3) 构造和析构函数的优先级
                void __attribute__((constructor(5))) init_function1(void);
                void __attribute__((constructor(10))) init_function2(void);

    - 共享库脚本: 我们可以把C运行库和数学库组合成一个新的库libfoo.c, 那么 libfoo.so的内容可以如下:
          -> GROUP( /lib/libc.so.6 /lib/libm.so.2)
