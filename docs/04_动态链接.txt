1.  空间浪费是静态链接的一个问题, 另一个问题是静态链对程序的更新, 部署和发布也会带来很多麻烦. 解决空间浪费和更新困难这两个问题最简单的办法就是把
    程序的模块相互分割开来, 形成独立的文件, 而不是将它们静态地链接在一起. 也就是说, 把链接这个过程推迟到了运行时在进行, 这就是动态链接的基本思想.


2.  在内存中共享一个目标文件模块的好处不仅仅是节省内存, 它还可以减少物理页面的换入换出, 也可以增加CPU缓存的命中率, 因为不同进程间的数据和指令访问
    都集中在同一个共享模块上.


3.  程序可扩展性和兼容性
    - 程序在运行时可以动态地选择加载各种程序模块, 制作程序的插件(Plug-in).
    - 动态链接还可以加强程序的兼容性. 一个程序在不同的平台运行时可以动态地链接到由操作系统提供的动态链接库, 这些动态链接库相当于在程序和操作系统
      之间增加了一个中间层, 从而消除了程序对不同平台之间依赖的差异性.


4.  动态链接的基本实现
    - 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分, 在程序运行时才将它们链接在一起形成一个完整的程序, 而不是像静态链接一样把所有的
      程序模块都链接成一个单独的可执行文件.
    - 在Linux系统中, ELF动态链接文件被称为动态共享对象, 简称共享对象. 它们一般都是以 .so 为扩展名的一些文件.
    - 在Windows系统中, 动态链接文件被称为动态链接库, 它们一般都是以 .dll 为扩展名的文件.


5.  在Linux中, 常用的C语言库的运行库 glibc, 它的动态链接形式的版本保存在"/lib"目录下, 文件名叫做"libc.so". 整个系统只保留一份C语言库的动态
    链接文件"libc.so". 而所有的C语言编写的, 动态链接的程序都可以在运行时使用它. 当程序被装载的时候, 系统的动态链接器会将程序所需要的所有动态
    链接库装载到进程的地址空间, 并且将程序中所有未决议的符号绑定到相应的动态链接库中, 并进行重定位工作.


6.  装载时重定位
    - 共享对象在任意地址装载: 在链接时, 对所有绝对地址的引用不作重定位, 而把这一步推迟到装载时在完成. 一旦模块装载地址确定, 即目标地址确定,
      那么系统就对程序中所有的绝对地址引用进行重定位.
    - 系统在装载程序的时候需要对程序的指令和数据中对绝对地址的引用进行重定位. 比静态链接中的重定位简单, 因为整个程序是按照一个整体被加载的,
      程序中指令和数据的相对位置是不会改变的.
    - 指令部分无法在多个进程之间共享.


7.  地址无关代码
    - 程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变, 所以实现的基本想法是把指令中那些需要被修改的部分分离出来, 跟数据部分放在
      一起, 这样指令部分就可以保持不变, 而数据部分可以在每个进程中拥有一个副本. 这种方案就是目前被称为地址无关代码的技术.
    - 模块内部 -> 指令跳转, 调用     相对跳转和调用
    - 模块内部 -> 数据访问           相对地址访问
    - 模块外部 -> 指令跳转, 调用     间接跳转和调用(GOT)
    - 模块外部 -> 数据访问           间接访问(GOT)


8.  地址无关代码技术除了可以用在共享对象上面, 它也可以用于可执行文件, 一个以地址无关方式编译的可执行文件被称作地址无关可执行文件.
     linux> gcc -fPIE -pie -o myprog myprog.c


9.  ELF共享库在编译时, 默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量, 通过GOT来实现变量的访问. 
    - 当共享模块被装载时, 如果某个全局变量在可执行文件中拥有副本, 那么动态链接器就会把GOT中的相应地址指向该副本, 这样该变量在运行时实际
      上最终就只有一个实例; 
    - 如果变量在共享模块中被初始化, 那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本;
    - 如果该全局变量在程序主模块中没有副本, 那么GOT中的相应地址就指向模块内部的该变量副本.


10. 对于数据段来说, 它在每个进程都有一份独立的副本, 所以并不担心被进程改变. 从这点来看, 我们可以选择装载时重定位的方法来解决数据段中绝对地址
    引用问题. 对于共享对象来说, 如果数据段中有绝对地址引用, 那么编译器和链接器就会产生一个重定位表, 这个重定位表里面包含了 "R_386_RELATIVE"
    类型的重定位入口, 用于解决上述问题. 当动态链接器装载共享对象时, 如果发现该共享对象有这样的重定位入口, 那么动态链接器就会对该共享对象进行
    重定位.


11. 延迟绑定(PLT)
    - 动态链接比静态链接慢的主要原因是动态链接下对于全局和静态的数据访问都要进行复杂的GOT定位, 然后间接寻址; 对于模块间的调用也要先定位GOT,
      然后再进行间接跳转, 如此一来, 程序的运行速度必定会减慢.

    - 另外一个减慢运行速度的原因是动态链接的链接工作在运行时完成, 即程序开始执行时, 动态链接器都要进行一次链接工作. 动态链接器会寻找并装载所
      需要的共享对象, 然后进行符号查找地址重定位等工作, 这些工作势必减慢程序的启动速度.

    - 在动态链接下, 程序模块之间包含了大量的函数引用(全局变量往往比较少, 因为大量的全局变量会导致模块之间耦合度变大), 所以在程序开始执行之前,
      动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找以及重定位.

    - ELF采用了一种叫做延迟绑定的做法, 基本的思想就是当函数第一次用到时才进行绑定(符号查找, 重定位等), 如果没有用到则不进行绑定. 所以程序
      开始执行时, 模块间的函数调用都没有进行绑定, 而是需要用到时才由动态链接器来负责绑定.


12. ELF将GOT拆分成了两个表叫做 .got 和 .got.plt; 其中 .got 用来保存全局变量引用的地址, .got.plt 用来保存函数引用的地址, 也就是说, 所有对于
    外部函数的引用全部被分离出来放到了 .got.plt中; 另外 .got.plt 还有一个特殊的地方是它的前三项具有特殊含义:
    - 第一项保存的是 .dynamic 段的地址, 这个段描述了本模块动态链接相关的信息.
    - 第二项保存的是本模块的ID.
    - 第三项保存的是 _dl_runtime_resolve()的地址.


13. 在Linux下, 动态链接器 ld.so 实际上是一个共享对象, 操作系统同样通过映射的方式将它加载到进程的地址空间中. 操作系统在加载完动态链接器之后,
    就将控制权交给动态链接器的入口地址. 当动态链接器得到控制权之后, 它开始执行一系列自身的初始化操作, 然后根据当前的环境参数, 开始对可执行
    文件进行动态链接工作. 当所有动态链接工作完成以后, 动态链接器会将控制权转交到可执行文件的入口地址, 程序开始正式执行.


14.  .interp 段
    - 动态链接器的位置既不是由系统配置的, 也不是由环境参数决定, 而是由ELF可执行文件决定. 在动态链接的ELF可执行文件中, 有一个专门的段叫做
      .interp段, .interp段的内容很简单, 里面保存的就是一个字符串, 这个字符串就是可执行文件所需要的动态链接器的路径.

    - Linux> readelf -l a.out | grep interpreter
          [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
          /lib64/ld-linux-x86-64.so.2 -> /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2

    - 动态链接器在Linux下是Glibc的一部分, 也就是属于系统库级别的, 它的版本号往往跟系统中的Glibc库版本号是一样的. 当系统中的Glibc库更新或者
      安装其他版本的时候, ld-linux-x86-64.so.2 这个软链接就会指向到新的动态链接器, 而可执行文件本身不需要修改 .interp 中的动态链接器路径来
      适应系统的升级.


15.  .dynamic 段
    - .dynamic段里面保存了动态链接器所需要的基本信息, 比如依赖于哪些共享对象, 动态链接符号表的位置, 动态链接重定位表的位置, 共享对象初始化
      代码的地址等.

    -   typedef struct
        {
          Elf64_Sxword  d_tag;                  /* Dynamic entry type */
          union
            {
              Elf64_Xword d_val;                /* Integer value */
              Elf64_Addr d_ptr;                 /* Address value */
            } d_un;
        } Elf64_Dyn;

    - Linux还提供一个命令用来查看一个程序主模块或一个共享库依赖于那些共享库
        -> ldd prog
                linux-vdso.so.1 (0x00007ffd2c5b7000)
                libc.so.6 => /usr/lib/x86_64-linux-gnu/libc.so.6 (0x00007f713e036000)
                /lib64/ld-linux-x86-64.so.2 (0x00007f713e276000)


16. 动态符号表
    - 为了表示动态链接这些模块之间的符号导入导出关系, ELF专门有一个叫做动态符号表的段用来保存信息, 这个段的段名通常叫做 .dynsym. 与
      .symtab 不同的是, .dynsym 只保存了与动态链接相关的符号.
    - 辅助的表: 动态符号字符串表, 符号哈希表


17. 动态链接重定位表
    - 共享对象需要重定位的主要原因是导入符号的存在. 在动态链接下, 无论是可执行文件或共享对象, 一旦它依赖于其他共享对象, 也就是说有导入的
      符号时, 那么它的代码或数据中就会有对于导入符号的引用. 在编译时这些导入符号的地址未知, 在静态链接中, 这些未知的地址引用在最终链接时
      被修正. 但是在动态链接中, 导入符号的地址在运行时才确定, 所以需要在运行时将这些导入符号的引用修正, 即需要重定位.

    - 目标文件的重定位是在静态链接时完成的, 而共享对象的重定位是在装载时完成的. 在静态链接中, 目标文件里面包含有专门用于表示重定位信息的
      重定位表, 比如 .rel.text 表示的是代码段的重定位表, .rel.data 是数据段的重定位表.

    - 动态链接的文件中, 也有类似的重定位表分别叫做 .rel.dyn 和 .rel.plt; .rel.dyn实际上是对数据引用的修正, 它所修正的位置位于 .got 以及
      数据段; 而 .rel.plt 是对函数引用的修正, 它所修正的位置位于 .got.plt

    - 在静态链接中, 两种类型的重定位入口 R_386_32 和 R_386_PC32. 动态链接中几种新的重定位入口类型: R_386_RELATIVE, R_386_GLOB_DAT 和
      R_386_JUMP_SLOT.


18. 动态链接的步骤和实现
    - 动态链接器自举
        (1) 动态链接器本身不可以依赖于其他任何共享对象; 其次是动态链接器本身所需要的全局和静态变量的重定位工作是由它本身完成.
            具有一定限制条件的启动代码往往被称为自举(bootstrap).
        (2) 动态链接器入口地址即是自举代码的入口, 当操作系统将进程控制权交给动态链接器时, 动态链接器的自举代码开始执行.

    - 装载共享对象
        (1) 当一个新的共享对象被装载进来的时候, 它的符号表会被合并到全局符号表中, 所以当所有的共享对象都被装载进来的时候, 全局符号表
            里面将包含进程中所有的动态链接所需要的符号.
        (2) 一个共享对象里面的全局符号被另一个共享对象的同名全局符号覆盖的现象被称为共享对象全局符号介入.
        (3) 当一个符号需要被加入全局符号表时, 如果相同的符号名已存在, 则后加入的符号被忽略.
        (4) 全局符号介入与地址无关代码: 为了提高模块内部函数调用的效率, 有一个办法是把 bar()函数变成编译单元私有函数, 即使用 static
            关键字定义 bar() 函数, 这种情况下, 编译器要确定 bar()函数不被其他模块覆盖, 就可以使用模块内部调用指令, 可以加快函数的
            调用速度.

    - 重定位和初始化
        (1) 链接器开始重新遍历可执行文件和每个共享对象的重定位表, 将它们的GOT/PLT中的每个需要被定位的位置进行修正. 此时动态链接器已经
            拥有了进程的全局符号表.
        (2) 重定位完成之后, 如果某个共享对象由 .init 段, 那么动态链接器会执行 .init 段中的代码, 用以实现共享对象特有的初始化过程.
            共享对象中的C++的全局/静态对象的构造就需要通过 .init 来初始化. 相应的, 共享对象中还可能有 .finit 段, 当进程退出时会
            执行 .finit 段中的代码, 可以用来实现类似 C++ 全局对象析构之类的操作.
        (3) 当完成重定位和初始化之后, 所需要的共享对象也都已经装载并且链接完成了, 将进程的控制权转交给程序的入口并且开始执行.


19. Linux动态链接器实现
    - 内核在装载完ELF可执行文件以后就返回到用户空间, 将控制权交给程序的入口. 对于静态链接的可执行文件来说, 程序的入口就是ELF文件头里面
      的 e_entry 指定的入口; 对于动态链接的可执行文件, 内核会分析它的动态链接器地址, 将动态链接器映射至进程地址空间, 然后把控制权交给
      动态链接器.
    - 动态链接器是个非常特殊的共享对象, 它不仅是个共享对象, 还是个可执行的程序.
    - 动态链接器本身应该是静态链接的, 它不能依赖于其他共享对象. 可以使用 ldd 判断.
    - 是不是PIC对于动态链接器来说并不关键, 动态链接器可以是PIC的也可以不是, 但往往使用PIC会更加简单一些.
    - 作为一个共享库, 内核在装载它时会为其选择一个合适的装载地址.


20. 显式运行时链接
    - 支持动态链接的系统往往都支持一种更加灵活的模块加载方式, 叫做显式运行时链接, 有时候也叫做运行时加载. 也就是让程序自己在运行时控制
      加载指定的模块, 并且可以在不需要该模块时将其卸载.
    - 动态库的装载则是通过一系列由动态链接器提供的API, 具体地讲共有4个函数: 打开动态库(dlopen), 查找符号(dlsym), 错误处理(dlerror),
      以及关闭动态库(dlclose).
    - dlopen(): dlopen()函数用来打开一个动态库, 并将其加载到进程的地址空间, 完成初始化过程.
             -> void *dlopen(const char *filename, int flag)
    - dlsym(): dlsym()函数基本上是运行时装载的核心部分, 可以通过这个函数找到所需要的符号.
             -> void *dlsym(void *handle, char *symbol)
    - dlerror(): dlerror()的返回值是 char*, 如果返回NULL, 则表示上一次调用成功; 如果不是, 则返回相应的错误信息.
    - dlclose(): dlclose()的作用跟dlopen()刚好相反, 它的作用是将一个已经加载的模块卸载. 系统会维持一个加载引用计数器, 每次使用dlopen()
                 加载某模块时, 相应的计数器加一; 每次使用dlclose()卸载某模块时, 相应计数器减一; 只有当计数器值减到0时, 模块才被真正的卸载.
